Design of a hardware system for performing matrix-vector multiplication, where the matrix is dense, and the vector is sparse. This is called “matrix-sparse vector multiplication”.  

We say a matrix or vector is considered sparse if many of its elements are equal to 0. If a matrix/vector is not sparse, we call it dense. Sparse data occurs in a very wide number of applications in science and engineering such as solving partial differential equations, circuit simulation, graph theory, and machine learning. Often, these applications operate on very large, very sparse matrices. This project is a less complex (but useful) variation of this problem: multiplication of a relatively small dense matrix with a sparse vector. Specifically, this problem is inspired by recent research on sparsity in transformer networks (e.g., GPT), which are commonly used in natural language applications such as chatbots.

//---------- 
Design flow

In the main module of the design, system just loops in a signle state all the time, but looping in different branches, based on the conditions system sees as it generates y[0], y[1] and so on. We maintain two counters, a counter to the track the row of a matrix, another to track the address of vector. In the beginning, when system sees a reset, we clear these counters and also set few control signals such as done, input valid, clear_acc  and a flag signal to zero. Until system sess input_loaded we just keep looping to 'READ' state, the only state in our FSM, by doing nothing ie., not setting any control signal. Here except for when vector address is '0', we keep looping here until vector address counter reaches value 'D', setting valid_input to '1' all along the way(except for vcounter==0). We set a flag to '1' at the end of the reading. Now, once flag is one, we pass the last 'valid_input' signal through a series of three 'flip flops' as this is how long it takes for mac unit to display accummulator output at the input to FIFO. Here, when the 3rd flip flop sets to '1'. we check for the FIFO's capacity to be >0. and we maintain the third flip flop at '1' until we FIFO has capacity to store atleast one element. Once this happens, we check if we finished reading/computing all rows or are we in the middle of matrix row reads, and head back to the same state, by either incrementing 'matrix row counter' or by clearning both counters and head back to 'READ' state by setting 'DONE' as 1, and again waiting for 'input_loaded' from input_mems module thereafter.
